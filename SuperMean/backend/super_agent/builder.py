import asyncio
from typing import Any, Dict, Optional, List, Callable, Coroutine, Set, Tuple
from datetime import datetime
from dataclasses import dataclass
from enum import Enum

from backend.agents.base_agent import BaseAgent
from backend.skills import execute_skill as execute_skill_function, SkillError
from backend.utils.logger import setup_logger
from backend.utils.error_handler import SuperMeanException

# Type hint for the async execute_skill function
ExecuteSkillType = Callable[..., Coroutine[Any, Any, Any]]

# Logger setup
log = setup_logger(name="super_agent_builder")

class StepStatus(Enum):
    """Enum for tracking step execution status."""
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    ROLLED_BACK = "rolled_back"

@dataclass
class StepMetrics:
    """Metrics for step execution."""
    start_time: datetime
    end_time: Optional[datetime] = None
    retries: int = 0
    error_count: int = 0
    memory_usage: Optional[float] = None
    executor_latency: Optional[float] = None

class BuildError(SuperMeanException):
    """Custom exception for plan execution failures."""
    def __init__(self, message="Failed to execute plan", step_id: Optional[int] = None, 
                cause: Optional[Exception] = None, status_code=500, is_recoverable: bool = True):
        full_message = f"Plan Execution Failed{f' at step {step_id}' if step_id is not None else ''}: {message}"
        super().__init__(full_message, status_code)
        if cause:
            self.__cause__ = cause
        self.is_recoverable = is_recoverable
        self.step_id = step_id

class Builder:
    """
    Advanced orchestrator for executing plans generated by the Planner.
    Features:
    - Parallel step execution where possible
    - Sophisticated error handling and recovery
    - Step validation and retry logic
    - Execution metrics and monitoring
    - Rollback capabilities for failed steps
    - Dynamic input resolution
    """

    def __init__(
        self,
        agents: Dict[str, BaseAgent],
        execute_skill_func: ExecuteSkillType,
        config: Optional[Dict[str, Any]] = None
    ):
        """
        Initialize the Builder with enhanced configuration.

        Args:
            agents: Dictionary mapping agent names to instances
            execute_skill_func: Function for executing skills
            config: Configuration including:
                - max_step_retries: Maximum retries per step
                - parallel_execution: Enable parallel execution
                - validation_required: Require step validation
                - collect_metrics: Enable metric collection
                - rollback_on_failure: Enable automatic rollback
        """
        self.agents = agents
        self.execute_skill = execute_skill_func
        self.config = config or {}
        
        # Enhanced configuration
        self.max_retries = self.config.get("max_step_retries", 2)
        self.parallel_execution = self.config.get("parallel_execution", True)
        self.validation_required = self.config.get("validation_required", True)
        self.collect_metrics = self.config.get("collect_metrics", True)
        self.rollback_on_failure = self.config.get("rollback_on_failure", True)
        
        # Execution state
        self.step_metrics: Dict[int, StepMetrics] = {}
        self.step_statuses: Dict[int, StepStatus] = {}
        self.rollback_handlers: Dict[int, Callable] = {}
        
        log.info(f"Advanced Builder initialized with {len(agents)} agents and enhanced capabilities")

    def _get_executor(self, executor_name: str) -> Optional[BaseAgent | ExecuteSkillType]:
        """Find the appropriate executor (agent or skill) by name."""
        if executor_name in self.agents:
            return self.agents[executor_name]
        elif "." in executor_name:
            return self.execute_skill
        else:
            log.warning(f"Executor '{executor_name}' not found in registered executors")
            return None

    def _prepare_inputs(self, required_inputs: List[str], step_outputs: Dict[int, Any], 
                       initial_context: Dict[str, Any]) -> Dict[str, Any]:
        """
        Enhanced input resolution with smart mapping and validation.

        Features:
        - Smart key mapping for common variations
        - Type validation and conversion
        - Default value handling
        - Circular dependency detection
        """
        resolved_inputs = {}
        missing_inputs = []
        
        # Track circular dependencies
        dependency_chain: Set[str] = set()
        
        for input_name in required_inputs:
            try:
                value = self._resolve_input(
                    input_name, 
                    step_outputs, 
                    initial_context, 
                    dependency_chain
                )
                if value is not None:
                    resolved_inputs[input_name] = value
                else:
                    missing_inputs.append(input_name)
            except RecursionError:
                log.error(f"Circular dependency detected for input: {input_name}")
                missing_inputs.append(f"{input_name} (circular dependency)")

        if missing_inputs:
            raise BuildError(f"Missing required inputs: {', '.join(missing_inputs)}")

        return self._normalize_input_keys(resolved_inputs)

    def _resolve_input(self, input_name: str, step_outputs: Dict[int, Any],
                      initial_context: Dict[str, Any], dependency_chain: Set[str]) -> Optional[Any]:
        """
        Recursively resolve an input value with circular dependency detection.
        """
        if input_name in dependency_chain:
            raise RecursionError(f"Circular dependency detected: {input_name}")
        
        dependency_chain.add(input_name)
        
        try:
            # Check initial context
            if input_name in initial_context:
                return initial_context[input_name]
            
            # Check previous step outputs with smart matching
            for step_id, output_data in step_outputs.items():
                if isinstance(output_data, dict):
                    # Try exact match
                    if input_name in output_data:
                        return output_data[input_name]
                    
                    # Try normalized key matching
                    normalized_input = self._normalize_key(input_name)
                    for key, value in output_data.items():
                        if self._normalize_key(key) == normalized_input:
                            return value
                
                # Handle direct value match
                if str(output_data) == input_name:
                    return output_data
            
            return None
            
        finally:
            dependency_chain.remove(input_name)

    def _normalize_key(self, key: str) -> str:
        """Normalize keys for consistent matching."""
        return key.lower().replace(" ", "_").replace("-", "_")

    def _normalize_input_keys(self, inputs: Dict[str, Any]) -> Dict[str, Any]:
        """Convert input keys to a consistent format for kwargs."""
        return {self._normalize_key(k): v for k, v in inputs.items()}

    async def _execute_step(self, step: Dict[str, Any], step_outputs: Dict[int, Any],
                          initial_context: Dict[str, Any]) -> Any:
        """
        Execute a single step with retries and metrics collection.
        """
        step_id = step["step_id"]
        action = step["action_description"]
        executor_name = step["suggested_executor"]
        required_inputs = step["required_inputs"]

        self.step_metrics[step_id] = StepMetrics(start_time=datetime.now())
        self.step_statuses[step_id] = StepStatus.RUNNING

        for attempt in range(self.max_retries + 1):
            try:
                # Get executor
                executor = self._get_executor(executor_name)
                if not executor:
                    raise BuildError(f"No executor found for '{executor_name}'", step_id=step_id)

                # Prepare inputs
                inputs = self._prepare_inputs(required_inputs, step_outputs, initial_context)
                
                # Execute
                start_time = datetime.now()
                if isinstance(executor, BaseAgent):
                    result = await executor.run(task_description=action, **inputs)
                    if not isinstance(result, dict) or result.get("status") != "success":
                        raise BuildError(
                            f"Agent execution failed: {result.get('error', 'Unknown error')}", 
                            step_id=step_id
                        )
                else:
                    result = await self.execute_skill(executor_name, **inputs)

                # Update metrics
                if self.collect_metrics:
                    metrics = self.step_metrics[step_id]
                    metrics.end_time = datetime.now()
                    metrics.executor_latency = (metrics.end_time - start_time).total_seconds()

                # Validate result if required
                if self.validation_required:
                    self._validate_step_result(step, result)

                self.step_statuses[step_id] = StepStatus.COMPLETED
                return result

            except Exception as e:
                self.step_metrics[step_id].error_count += 1
                
                if attempt < self.max_retries:
                    log.warning(f"Step {step_id} failed, attempt {attempt + 1}/{self.max_retries + 1}: {e}")
                    self.step_metrics[step_id].retries += 1
                    await asyncio.sleep(2 ** attempt)  # Exponential backoff
                else:
                    self.step_statuses[step_id] = StepStatus.FAILED
                    raise

    def _validate_step_result(self, step: Dict[str, Any], result: Any) -> None:
        """
        Validate step execution result against expected output criteria.
        """
        validation_criteria = step.get("validation_criteria", [])
        if not validation_criteria:
            return

        for criterion in validation_criteria:
            if not self._check_criterion(criterion, result):
                raise BuildError(
                    f"Step {step['step_id']} failed validation: {criterion}",
                    step_id=step['step_id']
                )

    def _check_criterion(self, criterion: str, result: Any) -> bool:
        """
        Check if a result meets a specific validation criterion.
        """
        if isinstance(result, dict):
            if criterion.startswith("has_key:"):
                key = criterion.split(":", 1)[1]
                return key in result
            elif criterion.startswith("status:"):
                status = criterion.split(":", 1)[1]
                return result.get("status") == status
        return True  # Default to true for unknown criteria

    async def _rollback_step(self, step_id: int) -> None:
        """
        Roll back a step's changes if possible.
        """
        if step_id in self.rollback_handlers:
            try:
                await self.rollback_handlers[step_id]()
                self.step_statuses[step_id] = StepStatus.ROLLED_BACK
                log.info(f"Successfully rolled back step {step_id}")
            except Exception as e:
                log.error(f"Failed to roll back step {step_id}: {e}")

    async def execute_plan(self, plan: List[Dict[str, Any]], 
                         initial_context: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Execute a plan with enhanced capabilities including parallel execution.

        Args:
            plan: List of step dictionaries from the Planner
            initial_context: Optional initial data

        Returns:
            Dict containing execution results and metrics
        """
        if not plan:
            return {"status": "success", "message": "Empty plan executed.", "step_outputs": {}}

        initial_context = initial_context or {}
        step_outputs: Dict[int, Any] = {}
        failed_steps: List[Tuple[int, str]] = []

        # Group steps by their dependencies for parallel execution
        step_groups = self._group_parallel_steps(plan, initial_context) if self.parallel_execution else [[s] for s in plan]

        try:
            for step_group in step_groups:
                # Execute steps in the group in parallel
                tasks = [
                    self._execute_step(step, step_outputs, initial_context)
                    for step in step_group
                ]
                
                if len(tasks) == 1:
                    # Single step execution
                    try:
                        result = await tasks[0]
                        step_outputs[step_group[0]["step_id"]] = result
                    except Exception as e:
                        self._handle_step_failure(step_group[0], e, failed_steps)
                else:
                    # Parallel execution
                    results = await asyncio.gather(*tasks, return_exceptions=True)
                    for step, result in zip(step_group, results):
                        if isinstance(result, Exception):
                            self._handle_step_failure(step, result, failed_steps)
                        else:
                            step_outputs[step["step_id"]] = result

                if failed_steps and not self._can_continue_after_failure(failed_steps):
                    break

        except Exception as e:
            log.exception("Unexpected error during plan execution")
            return {
                "status": "failed",
                "error": str(e),
                "failed_steps": failed_steps,
                "step_outputs": step_outputs,
                "metrics": self._collect_execution_metrics()
            }

        # Handle failures and rollback if needed
        if failed_steps:
            if self.rollback_on_failure:
                await self._rollback_failed_steps(failed_steps)
            return {
                "status": "failed",
                "failed_steps": failed_steps,
                "step_outputs": step_outputs,
                "metrics": self._collect_execution_metrics()
            }

        # Success case
        final_step_id = plan[-1]["step_id"] if plan else -1
        return {
            "status": "success",
            "step_outputs": step_outputs,
            "final_result": step_outputs.get(final_step_id),
            "metrics": self._collect_execution_metrics()
        }

    def _group_parallel_steps(self, plan: List[Dict[str, Any]], initial_context: Dict[str, Any]) -> List[List[Dict[str, Any]]]:
        """
        Group steps that can be executed in parallel based on dependencies.
        """
        groups: List[List[Dict[str, Any]]] = []
        current_group: List[Dict[str, Any]] = []
        completed_outputs: Set[str] = set()

        for step in plan:
            required_inputs = set(step["required_inputs"])
            if not required_inputs - completed_outputs - set(initial_context.keys()):
                # Step can be executed with available outputs
                current_group.append(step)
            else:
                # Step needs previous outputs
                if current_group:
                    groups.append(current_group)
                    completed_outputs.update(s["expected_output"] for s in current_group)
                current_group = [step]

        if current_group:
            groups.append(current_group)

        return groups

    def _handle_step_failure(self, step: Dict[str, Any], error: Exception,
                           failed_steps: List[Tuple[int, str]]) -> None:
        """
        Handle a step failure and update tracking information.
        """
        step_id = step["step_id"]
        error_msg = str(error)
        if isinstance(error, BuildError):
            error_msg = error.message
        failed_steps.append((step_id, error_msg))
        log.error(f"Step {step_id} failed: {error_msg}")

    def _can_continue_after_failure(self, failed_steps: List[Tuple[int, str]]) -> bool:
        """
        Determine if plan execution can continue after step failures.
        """
        return not any(
            isinstance(e, BuildError) and not e.is_recoverable
            for _, e in failed_steps
        )

    async def _rollback_failed_steps(self, failed_steps: List[Tuple[int, str]]) -> None:
        """
        Roll back steps that failed in reverse order.
        """
        for step_id, _ in reversed(failed_steps):
            await self._rollback_step(step_id)

    def _collect_execution_metrics(self) -> Dict[str, Any]:
        """
        Collect and summarize execution metrics.
        """
        if not self.collect_metrics:
            return {}

        total_duration = 0
        total_retries = 0
        total_errors = 0
        step_times: Dict[int, float] = {}

        for step_id, metrics in self.step_metrics.items():
            if metrics.end_time:
                duration = (metrics.end_time - metrics.start_time).total_seconds()
                step_times[step_id] = duration
                total_duration += duration
            total_retries += metrics.retries
            total_errors += metrics.error_count

        return {
            "total_duration": total_duration,
            "total_retries": total_retries,
            "total_errors": total_errors,
            "step_durations": step_times,
            "step_statuses": {k: v.value for k, v in self.step_statuses.items()}
        }